#version 430 core

// Match the local size to the grid dispatch (e.g., 16, 9, 1) or keep 1,1,1 for simplicity
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Cluster 
{
    vec4 minPoint;
    vec4 maxPoint;
    uint count;           // Matches C++ uint32_t count
    uint lightIndices[100]; // Matches C++ lightIndices[100]
    uint _padding[3];     // Matches C++ _padding[3]
};

layout(std430, binding = 2) buffer ClusterBuffer
{
    Cluster clusters[];
};

layout(std140, binding = 0) uniform CameraData
{
    mat4 projection;
    mat4 view;
    float nearPlane;
    float farPlane;
};

uniform uvec3 u_GridSize;
uniform vec2 u_ScreenSize;

vec4 screenToView(vec4 screen)
{
    vec2 texCoord = screen.xy / u_ScreenSize;
    vec4 clip = vec4(texCoord * 2.0 - 1.0, screen.z, screen.w);
    vec4 view = inverse(projection) * clip;
    return view / view.w;
}

void main()
{
    // Calculate global index
    uint clusterIndex = gl_GlobalInvocationID.x +
                        gl_GlobalInvocationID.y * u_GridSize.x +
                        gl_GlobalInvocationID.z * u_GridSize.x * u_GridSize.y;

    vec2 tileSize = u_ScreenSize / vec2(u_GridSize.xy);

    // 1. Calculate screen space bounds
    vec4 minPointSS = vec4(vec2(gl_GlobalInvocationID.xy) * tileSize, -1.0, 1.0);
    vec4 maxPointSS = vec4(vec2(gl_GlobalInvocationID.xy + 1) * tileSize, -1.0, 1.0);

    // 2. Convert to view space
    vec3 minPointVS = screenToView(minPointSS).xyz;
    vec3 maxPointVS = screenToView(maxPointSS).xyz;

    // 3. Logarithmic Z-Slicing 
    float zNear = nearPlane * pow(farPlane / nearPlane, gl_GlobalInvocationID.z / float(u_GridSize.z));
    float zFar  = nearPlane * pow(farPlane / nearPlane, (gl_GlobalInvocationID.z + 1) / float(u_GridSize.z));

    // 4. Project rays to the specific Z planes of this cluster
    vec3 minPointNear = minPointVS * (-zNear / minPointVS.z);
    vec3 minPointFar  = minPointVS * (-zFar / minPointVS.z);
    vec3 maxPointNear = maxPointVS * (-zNear / maxPointVS.z);
    vec3 maxPointFar  = maxPointVS * (-zFar / maxPointVS.z);

    vec3 minBounds = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
    vec3 maxBounds = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

    // 5. Write only the AABB bounds
    clusters[clusterIndex].minPoint = vec4(minBounds, 1.0);
    clusters[clusterIndex].maxPoint = vec4(maxBounds, 1.0);
    
    // IMPORTANT: Initialize count to 0 so the light culler starts fresh
    clusters[clusterIndex].count = 0; 
}