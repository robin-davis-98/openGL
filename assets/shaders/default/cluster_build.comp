#version 430 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Cluster 
{
    vec4 minPoint;
    vec4 maxPoint;
}; // Added missing semicolon

layout(std430, binding = 2) buffer ClusterBuffer
{
    Cluster clusters[];
};

layout(std140, binding = 0) uniform CameraData
{
    mat4 projection;
    mat4 view;
    float nearPlane;
    float farPlane;
};

uniform uvec3 u_GridSize;
uniform vec2 u_ScreenSize;

vec4 screenToView(vec4 screen)
{
    vec2 texCoord = screen.xy / u_ScreenSize;
    vec4 clip = vec4(texCoord * 2.0 - 1.0, screen.z, screen.w);
    vec4 view = inverse(projection) * clip;
    return view / view.w;
}

void main()
{
    uint clusterIndex = gl_GlobalInvocationID.x +
                        gl_GlobalInvocationID.y * u_GridSize.x +
                        gl_GlobalInvocationID.z * u_GridSize.x * u_GridSize.y;

    // 1. Calculate the tile size in screen space (pixels)
    vec2 tileSize = u_ScreenSize / vec2(u_GridSize.xy);

    // 2. Find the min/max 2D points for this tile in screen space
    // Using gl_GlobalInvocationID for the current cluster's X and Y
    vec4 minPointSS = vec4(vec2(gl_GlobalInvocationID.xy) * tileSize, -1.0, 1.0);
    vec4 maxPointSS = vec4(vec2(gl_GlobalInvocationID.xy + 1) * tileSize, -1.0, 1.0);

    // 3. Convert screen space to view space (at the near plane)
    vec3 minPointVS = screenToView(minPointSS).xyz;
    vec3 maxPointVS = screenToView(maxPointSS).xyz;

    // 4. Calculate Depth (Z) for this cluster slice
    // We use exponential distribution so clusters are smaller near the camera
    float zNear = nearPlane * pow(farPlane / nearPlane, gl_GlobalInvocationID.z / float(u_GridSize.z));
    float zFar  = nearPlane * pow(farPlane / nearPlane, (gl_GlobalInvocationID.z + 1) / float(u_GridSize.z));

    // 5. Intersect the frustum rays with the near and far Z-planes of the cluster
    // Since view space looks down -Z, we multiply by -zNear and -zFar
    vec3 minPointNear = minPointVS * (-zNear / minPointVS.z);
    vec3 minPointFar  = minPointVS * (-zFar / minPointVS.z);
    vec3 maxPointNear = maxPointVS * (-zNear / maxPointVS.z);
    vec3 maxPointFar  = maxPointVS * (-zFar / maxPointVS.z);

    // 6. Compute AABB min/max bounds from the 8 corners
    // In view space, Z is negative, so minZ is actually -zFar and maxZ is -zNear
    vec3 minBounds = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
    vec3 maxBounds = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

    clusters[clusterIndex].minPoint = vec4(minBounds, 1.0);
    clusters[clusterIndex].maxPoint = vec4(maxBounds, 1.0);
}